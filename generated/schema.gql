# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateGym {
  _avg: GymAvgAggregate
  _count: GymCountAggregate
  _max: GymMaxAggregate
  _min: GymMinAggregate
  _sum: GymSumAggregate
}

type AggregatePost {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
}

type AggregatePreferredDayAndTime {
  _avg: PreferredDayAndTimeAvgAggregate
  _count: PreferredDayAndTimeCountAggregate
  _max: PreferredDayAndTimeMaxAggregate
  _min: PreferredDayAndTimeMinAggregate
  _sum: PreferredDayAndTimeSumAggregate
}

enum ClimbingType {
  BOTH
  BOULDER
  LEAD
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumClimbingTypeFieldUpdateOperationsInput {
  set: ClimbingType
}

input EnumClimbingTypeFilter {
  equals: ClimbingType
  in: [ClimbingType!]
  not: NestedEnumClimbingTypeFilter
  notIn: [ClimbingType!]
}

input EnumClimbingTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumClimbingTypeFilter
  _min: NestedEnumClimbingTypeFilter
  equals: ClimbingType
  in: [ClimbingType!]
  not: NestedEnumClimbingTypeWithAggregatesFilter
  notIn: [ClimbingType!]
}

type Gym {
  Posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  _count: GymCount
  climbingType: ClimbingType!
  id: Int!
  image: String
  name: String!
}

type GymAvgAggregate {
  id: Float
}

input GymAvgOrderByAggregateInput {
  id: SortOrder
}

type GymCount {
  Posts: Int!
}

type GymCountAggregate {
  _all: Int!
  climbingType: Int!
  id: Int!
  image: Int!
  name: Int!
}

input GymCountOrderByAggregateInput {
  climbingType: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
}

input GymCreateInput {
  Posts: PostCreateNestedManyWithoutGymInput
  climbingType: ClimbingType!
  image: String
  name: String!
}

input GymCreateManyInput {
  climbingType: ClimbingType!
  id: Int
  image: String
  name: String!
}

input GymCreateNestedOneWithoutPostsInput {
  connect: GymWhereUniqueInput
  connectOrCreate: GymCreateOrConnectWithoutPostsInput
  create: GymCreateWithoutPostsInput
}

input GymCreateOrConnectWithoutPostsInput {
  create: GymCreateWithoutPostsInput!
  where: GymWhereUniqueInput!
}

input GymCreateWithoutPostsInput {
  climbingType: ClimbingType!
  image: String
  name: String!
}

type GymGroupBy {
  _avg: GymAvgAggregate
  _count: GymCountAggregate
  _max: GymMaxAggregate
  _min: GymMinAggregate
  _sum: GymSumAggregate
  climbingType: ClimbingType!
  id: Int!
  image: String
  name: String!
}

type GymMaxAggregate {
  climbingType: ClimbingType
  id: Int
  image: String
  name: String
}

input GymMaxOrderByAggregateInput {
  climbingType: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
}

type GymMinAggregate {
  climbingType: ClimbingType
  id: Int
  image: String
  name: String
}

input GymMinOrderByAggregateInput {
  climbingType: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
}

input GymOrderByWithAggregationInput {
  _avg: GymAvgOrderByAggregateInput
  _count: GymCountOrderByAggregateInput
  _max: GymMaxOrderByAggregateInput
  _min: GymMinOrderByAggregateInput
  _sum: GymSumOrderByAggregateInput
  climbingType: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
}

input GymOrderByWithRelationInput {
  Posts: PostOrderByRelationAggregateInput
  climbingType: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
}

input GymRelationFilter {
  is: GymWhereInput
  isNot: GymWhereInput
}

enum GymScalarFieldEnum {
  climbingType
  id
  image
  name
}

input GymScalarWhereWithAggregatesInput {
  AND: [GymScalarWhereWithAggregatesInput!]
  NOT: [GymScalarWhereWithAggregatesInput!]
  OR: [GymScalarWhereWithAggregatesInput!]
  climbingType: EnumClimbingTypeWithAggregatesFilter
  id: IntWithAggregatesFilter
  image: StringNullableWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type GymSumAggregate {
  id: Int
}

input GymSumOrderByAggregateInput {
  id: SortOrder
}

input GymUpdateInput {
  Posts: PostUpdateManyWithoutGymNestedInput
  climbingType: EnumClimbingTypeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input GymUpdateManyMutationInput {
  climbingType: EnumClimbingTypeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input GymUpdateOneRequiredWithoutPostsNestedInput {
  connect: GymWhereUniqueInput
  connectOrCreate: GymCreateOrConnectWithoutPostsInput
  create: GymCreateWithoutPostsInput
  update: GymUpdateWithoutPostsInput
  upsert: GymUpsertWithoutPostsInput
}

input GymUpdateWithoutPostsInput {
  climbingType: EnumClimbingTypeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input GymUpsertWithoutPostsInput {
  create: GymCreateWithoutPostsInput!
  update: GymUpdateWithoutPostsInput!
}

input GymWhereInput {
  AND: [GymWhereInput!]
  NOT: [GymWhereInput!]
  OR: [GymWhereInput!]
  Posts: PostListRelationFilter
  climbingType: EnumClimbingTypeFilter
  id: IntFilter
  image: StringNullableFilter
  name: StringFilter
}

input GymWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyGym(data: [GymCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPost(data: [PostCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPreferredDayAndTime(data: [PreferredDayAndTimeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneGym(data: GymCreateInput!): Gym!
  createOnePost(data: PostCreateInput!): Post!
  createOnePreferredDayAndTime(data: PreferredDayAndTimeCreateInput!): PreferredDayAndTime!
  deleteManyGym(where: GymWhereInput): AffectedRowsOutput!
  deleteManyPost(where: PostWhereInput): AffectedRowsOutput!
  deleteManyPreferredDayAndTime(where: PreferredDayAndTimeWhereInput): AffectedRowsOutput!
  deleteOneGym(where: GymWhereUniqueInput!): Gym
  deleteOnePost(where: PostWhereUniqueInput!): Post
  deleteOnePreferredDayAndTime(where: PreferredDayAndTimeWhereUniqueInput!): PreferredDayAndTime
  updateManyGym(data: GymUpdateManyMutationInput!, where: GymWhereInput): AffectedRowsOutput!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updateManyPreferredDayAndTime(data: PreferredDayAndTimeUpdateManyMutationInput!, where: PreferredDayAndTimeWhereInput): AffectedRowsOutput!
  updateOneGym(data: GymUpdateInput!, where: GymWhereUniqueInput!): Gym
  updateOnePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateOnePreferredDayAndTime(data: PreferredDayAndTimeUpdateInput!, where: PreferredDayAndTimeWhereUniqueInput!): PreferredDayAndTime
  upsertOneGym(create: GymCreateInput!, update: GymUpdateInput!, where: GymWhereUniqueInput!): Gym!
  upsertOnePost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  upsertOnePreferredDayAndTime(create: PreferredDayAndTimeCreateInput!, update: PreferredDayAndTimeUpdateInput!, where: PreferredDayAndTimeWhereUniqueInput!): PreferredDayAndTime!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumClimbingTypeFilter {
  equals: ClimbingType
  in: [ClimbingType!]
  not: NestedEnumClimbingTypeFilter
  notIn: [ClimbingType!]
}

input NestedEnumClimbingTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumClimbingTypeFilter
  _min: NestedEnumClimbingTypeFilter
  equals: ClimbingType
  in: [ClimbingType!]
  not: NestedEnumClimbingTypeWithAggregatesFilter
  notIn: [ClimbingType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Post {
  _count: PostCount
  belayMonths: Int!
  climbingType: ClimbingType!
  content: String!
  createdAt: DateTime!
  deletedAt: DateTime
  experienceMonths: Int!
  grade: String!
  gym: Gym!
  gymId: Int!
  id: Int!
  preferredDayAndTimes(cursor: PreferredDayAndTimeWhereUniqueInput, distinct: [PreferredDayAndTimeScalarFieldEnum!], orderBy: [PreferredDayAndTimeOrderByWithRelationInput!], skip: Int, take: Int, where: PreferredDayAndTimeWhereInput): [PreferredDayAndTime!]!
  title: String!
  updatedAt: DateTime!
}

type PostAvgAggregate {
  belayMonths: Float
  experienceMonths: Float
  gymId: Float
  id: Float
}

input PostAvgOrderByAggregateInput {
  belayMonths: SortOrder
  experienceMonths: SortOrder
  gymId: SortOrder
  id: SortOrder
}

type PostCount {
  preferredDayAndTimes: Int!
}

type PostCountAggregate {
  _all: Int!
  belayMonths: Int!
  climbingType: Int!
  content: Int!
  createdAt: Int!
  deletedAt: Int!
  experienceMonths: Int!
  grade: Int!
  gymId: Int!
  id: Int!
  title: Int!
  updatedAt: Int!
}

input PostCountOrderByAggregateInput {
  belayMonths: SortOrder
  climbingType: SortOrder
  content: SortOrder
  createdAt: SortOrder
  deletedAt: SortOrder
  experienceMonths: SortOrder
  grade: SortOrder
  gymId: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input PostCreateInput {
  belayMonths: Int!
  climbingType: ClimbingType!
  content: String!
  createdAt: DateTime
  deletedAt: DateTime
  experienceMonths: Int!
  grade: String!
  gym: GymCreateNestedOneWithoutPostsInput!
  preferredDayAndTimes: PreferredDayAndTimeCreateNestedManyWithoutPostInput
  title: String!
  updatedAt: DateTime
}

input PostCreateManyGymInput {
  belayMonths: Int!
  climbingType: ClimbingType!
  content: String!
  createdAt: DateTime
  deletedAt: DateTime
  experienceMonths: Int!
  grade: String!
  id: Int
  title: String!
  updatedAt: DateTime
}

input PostCreateManyGymInputEnvelope {
  data: [PostCreateManyGymInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyInput {
  belayMonths: Int!
  climbingType: ClimbingType!
  content: String!
  createdAt: DateTime
  deletedAt: DateTime
  experienceMonths: Int!
  grade: String!
  gymId: Int!
  id: Int
  title: String!
  updatedAt: DateTime
}

input PostCreateNestedManyWithoutGymInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutGymInput!]
  create: [PostCreateWithoutGymInput!]
  createMany: PostCreateManyGymInputEnvelope
}

input PostCreateNestedOneWithoutPreferredDayAndTimesInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutPreferredDayAndTimesInput
  create: PostCreateWithoutPreferredDayAndTimesInput
}

input PostCreateOrConnectWithoutGymInput {
  create: PostCreateWithoutGymInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutPreferredDayAndTimesInput {
  create: PostCreateWithoutPreferredDayAndTimesInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutGymInput {
  belayMonths: Int!
  climbingType: ClimbingType!
  content: String!
  createdAt: DateTime
  deletedAt: DateTime
  experienceMonths: Int!
  grade: String!
  preferredDayAndTimes: PreferredDayAndTimeCreateNestedManyWithoutPostInput
  title: String!
  updatedAt: DateTime
}

input PostCreateWithoutPreferredDayAndTimesInput {
  belayMonths: Int!
  climbingType: ClimbingType!
  content: String!
  createdAt: DateTime
  deletedAt: DateTime
  experienceMonths: Int!
  grade: String!
  gym: GymCreateNestedOneWithoutPostsInput!
  title: String!
  updatedAt: DateTime
}

type PostGroupBy {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
  belayMonths: Int!
  climbingType: ClimbingType!
  content: String!
  createdAt: DateTime!
  deletedAt: DateTime
  experienceMonths: Int!
  grade: String!
  gymId: Int!
  id: Int!
  title: String!
  updatedAt: DateTime!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregate {
  belayMonths: Int
  climbingType: ClimbingType
  content: String
  createdAt: DateTime
  deletedAt: DateTime
  experienceMonths: Int
  grade: String
  gymId: Int
  id: Int
  title: String
  updatedAt: DateTime
}

input PostMaxOrderByAggregateInput {
  belayMonths: SortOrder
  climbingType: SortOrder
  content: SortOrder
  createdAt: SortOrder
  deletedAt: SortOrder
  experienceMonths: SortOrder
  grade: SortOrder
  gymId: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type PostMinAggregate {
  belayMonths: Int
  climbingType: ClimbingType
  content: String
  createdAt: DateTime
  deletedAt: DateTime
  experienceMonths: Int
  grade: String
  gymId: Int
  id: Int
  title: String
  updatedAt: DateTime
}

input PostMinOrderByAggregateInput {
  belayMonths: SortOrder
  climbingType: SortOrder
  content: SortOrder
  createdAt: SortOrder
  deletedAt: SortOrder
  experienceMonths: SortOrder
  grade: SortOrder
  gymId: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostOrderByWithAggregationInput {
  _avg: PostAvgOrderByAggregateInput
  _count: PostCountOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  _sum: PostSumOrderByAggregateInput
  belayMonths: SortOrder
  climbingType: SortOrder
  content: SortOrder
  createdAt: SortOrder
  deletedAt: SortOrder
  experienceMonths: SortOrder
  grade: SortOrder
  gymId: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input PostOrderByWithRelationInput {
  belayMonths: SortOrder
  climbingType: SortOrder
  content: SortOrder
  createdAt: SortOrder
  deletedAt: SortOrder
  experienceMonths: SortOrder
  grade: SortOrder
  gym: GymOrderByWithRelationInput
  gymId: SortOrder
  id: SortOrder
  preferredDayAndTimes: PreferredDayAndTimeOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

enum PostScalarFieldEnum {
  belayMonths
  climbingType
  content
  createdAt
  deletedAt
  experienceMonths
  grade
  gymId
  id
  title
  updatedAt
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  belayMonths: IntFilter
  climbingType: EnumClimbingTypeFilter
  content: StringFilter
  createdAt: DateTimeFilter
  deletedAt: DateTimeNullableFilter
  experienceMonths: IntFilter
  grade: StringFilter
  gymId: IntFilter
  id: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  belayMonths: IntWithAggregatesFilter
  climbingType: EnumClimbingTypeWithAggregatesFilter
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  deletedAt: DateTimeNullableWithAggregatesFilter
  experienceMonths: IntWithAggregatesFilter
  grade: StringWithAggregatesFilter
  gymId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type PostSumAggregate {
  belayMonths: Int
  experienceMonths: Int
  gymId: Int
  id: Int
}

input PostSumOrderByAggregateInput {
  belayMonths: SortOrder
  experienceMonths: SortOrder
  gymId: SortOrder
  id: SortOrder
}

input PostUpdateInput {
  belayMonths: IntFieldUpdateOperationsInput
  climbingType: EnumClimbingTypeFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deletedAt: NullableDateTimeFieldUpdateOperationsInput
  experienceMonths: IntFieldUpdateOperationsInput
  grade: StringFieldUpdateOperationsInput
  gym: GymUpdateOneRequiredWithoutPostsNestedInput
  preferredDayAndTimes: PreferredDayAndTimeUpdateManyWithoutPostNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
  belayMonths: IntFieldUpdateOperationsInput
  climbingType: EnumClimbingTypeFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deletedAt: NullableDateTimeFieldUpdateOperationsInput
  experienceMonths: IntFieldUpdateOperationsInput
  grade: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyWithWhereWithoutGymInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutGymNestedInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutGymInput!]
  create: [PostCreateWithoutGymInput!]
  createMany: PostCreateManyGymInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutGymInput!]
  updateMany: [PostUpdateManyWithWhereWithoutGymInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutGymInput!]
}

input PostUpdateOneRequiredWithoutPreferredDayAndTimesNestedInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutPreferredDayAndTimesInput
  create: PostCreateWithoutPreferredDayAndTimesInput
  update: PostUpdateWithoutPreferredDayAndTimesInput
  upsert: PostUpsertWithoutPreferredDayAndTimesInput
}

input PostUpdateWithWhereUniqueWithoutGymInput {
  data: PostUpdateWithoutGymInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutGymInput {
  belayMonths: IntFieldUpdateOperationsInput
  climbingType: EnumClimbingTypeFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deletedAt: NullableDateTimeFieldUpdateOperationsInput
  experienceMonths: IntFieldUpdateOperationsInput
  grade: StringFieldUpdateOperationsInput
  preferredDayAndTimes: PreferredDayAndTimeUpdateManyWithoutPostNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateWithoutPreferredDayAndTimesInput {
  belayMonths: IntFieldUpdateOperationsInput
  climbingType: EnumClimbingTypeFieldUpdateOperationsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deletedAt: NullableDateTimeFieldUpdateOperationsInput
  experienceMonths: IntFieldUpdateOperationsInput
  grade: StringFieldUpdateOperationsInput
  gym: GymUpdateOneRequiredWithoutPostsNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpsertWithWhereUniqueWithoutGymInput {
  create: PostCreateWithoutGymInput!
  update: PostUpdateWithoutGymInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutPreferredDayAndTimesInput {
  create: PostCreateWithoutPreferredDayAndTimesInput!
  update: PostUpdateWithoutPreferredDayAndTimesInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  belayMonths: IntFilter
  climbingType: EnumClimbingTypeFilter
  content: StringFilter
  createdAt: DateTimeFilter
  deletedAt: DateTimeNullableFilter
  experienceMonths: IntFilter
  grade: StringFilter
  gym: GymRelationFilter
  gymId: IntFilter
  id: IntFilter
  preferredDayAndTimes: PreferredDayAndTimeListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input PostWhereUniqueInput {
  id: Int
}

type PreferredDayAndTime {
  dayAndTime: String!
  id: Int!
  post: Post!
  postId: Int!
}

type PreferredDayAndTimeAvgAggregate {
  id: Float
  postId: Float
}

input PreferredDayAndTimeAvgOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
}

type PreferredDayAndTimeCountAggregate {
  _all: Int!
  dayAndTime: Int!
  id: Int!
  postId: Int!
}

input PreferredDayAndTimeCountOrderByAggregateInput {
  dayAndTime: SortOrder
  id: SortOrder
  postId: SortOrder
}

input PreferredDayAndTimeCreateInput {
  dayAndTime: String!
  post: PostCreateNestedOneWithoutPreferredDayAndTimesInput!
}

input PreferredDayAndTimeCreateManyInput {
  dayAndTime: String!
  id: Int
  postId: Int!
}

input PreferredDayAndTimeCreateManyPostInput {
  dayAndTime: String!
  id: Int
}

input PreferredDayAndTimeCreateManyPostInputEnvelope {
  data: [PreferredDayAndTimeCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input PreferredDayAndTimeCreateNestedManyWithoutPostInput {
  connect: [PreferredDayAndTimeWhereUniqueInput!]
  connectOrCreate: [PreferredDayAndTimeCreateOrConnectWithoutPostInput!]
  create: [PreferredDayAndTimeCreateWithoutPostInput!]
  createMany: PreferredDayAndTimeCreateManyPostInputEnvelope
}

input PreferredDayAndTimeCreateOrConnectWithoutPostInput {
  create: PreferredDayAndTimeCreateWithoutPostInput!
  where: PreferredDayAndTimeWhereUniqueInput!
}

input PreferredDayAndTimeCreateWithoutPostInput {
  dayAndTime: String!
}

type PreferredDayAndTimeGroupBy {
  _avg: PreferredDayAndTimeAvgAggregate
  _count: PreferredDayAndTimeCountAggregate
  _max: PreferredDayAndTimeMaxAggregate
  _min: PreferredDayAndTimeMinAggregate
  _sum: PreferredDayAndTimeSumAggregate
  dayAndTime: String!
  id: Int!
  postId: Int!
}

input PreferredDayAndTimeListRelationFilter {
  every: PreferredDayAndTimeWhereInput
  none: PreferredDayAndTimeWhereInput
  some: PreferredDayAndTimeWhereInput
}

type PreferredDayAndTimeMaxAggregate {
  dayAndTime: String
  id: Int
  postId: Int
}

input PreferredDayAndTimeMaxOrderByAggregateInput {
  dayAndTime: SortOrder
  id: SortOrder
  postId: SortOrder
}

type PreferredDayAndTimeMinAggregate {
  dayAndTime: String
  id: Int
  postId: Int
}

input PreferredDayAndTimeMinOrderByAggregateInput {
  dayAndTime: SortOrder
  id: SortOrder
  postId: SortOrder
}

input PreferredDayAndTimeOrderByRelationAggregateInput {
  _count: SortOrder
}

input PreferredDayAndTimeOrderByWithAggregationInput {
  _avg: PreferredDayAndTimeAvgOrderByAggregateInput
  _count: PreferredDayAndTimeCountOrderByAggregateInput
  _max: PreferredDayAndTimeMaxOrderByAggregateInput
  _min: PreferredDayAndTimeMinOrderByAggregateInput
  _sum: PreferredDayAndTimeSumOrderByAggregateInput
  dayAndTime: SortOrder
  id: SortOrder
  postId: SortOrder
}

input PreferredDayAndTimeOrderByWithRelationInput {
  dayAndTime: SortOrder
  id: SortOrder
  post: PostOrderByWithRelationInput
  postId: SortOrder
}

enum PreferredDayAndTimeScalarFieldEnum {
  dayAndTime
  id
  postId
}

input PreferredDayAndTimeScalarWhereInput {
  AND: [PreferredDayAndTimeScalarWhereInput!]
  NOT: [PreferredDayAndTimeScalarWhereInput!]
  OR: [PreferredDayAndTimeScalarWhereInput!]
  dayAndTime: StringFilter
  id: IntFilter
  postId: IntFilter
}

input PreferredDayAndTimeScalarWhereWithAggregatesInput {
  AND: [PreferredDayAndTimeScalarWhereWithAggregatesInput!]
  NOT: [PreferredDayAndTimeScalarWhereWithAggregatesInput!]
  OR: [PreferredDayAndTimeScalarWhereWithAggregatesInput!]
  dayAndTime: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  postId: IntWithAggregatesFilter
}

type PreferredDayAndTimeSumAggregate {
  id: Int
  postId: Int
}

input PreferredDayAndTimeSumOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
}

input PreferredDayAndTimeUpdateInput {
  dayAndTime: StringFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutPreferredDayAndTimesNestedInput
}

input PreferredDayAndTimeUpdateManyMutationInput {
  dayAndTime: StringFieldUpdateOperationsInput
}

input PreferredDayAndTimeUpdateManyWithWhereWithoutPostInput {
  data: PreferredDayAndTimeUpdateManyMutationInput!
  where: PreferredDayAndTimeScalarWhereInput!
}

input PreferredDayAndTimeUpdateManyWithoutPostNestedInput {
  connect: [PreferredDayAndTimeWhereUniqueInput!]
  connectOrCreate: [PreferredDayAndTimeCreateOrConnectWithoutPostInput!]
  create: [PreferredDayAndTimeCreateWithoutPostInput!]
  createMany: PreferredDayAndTimeCreateManyPostInputEnvelope
  delete: [PreferredDayAndTimeWhereUniqueInput!]
  deleteMany: [PreferredDayAndTimeScalarWhereInput!]
  disconnect: [PreferredDayAndTimeWhereUniqueInput!]
  set: [PreferredDayAndTimeWhereUniqueInput!]
  update: [PreferredDayAndTimeUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [PreferredDayAndTimeUpdateManyWithWhereWithoutPostInput!]
  upsert: [PreferredDayAndTimeUpsertWithWhereUniqueWithoutPostInput!]
}

input PreferredDayAndTimeUpdateWithWhereUniqueWithoutPostInput {
  data: PreferredDayAndTimeUpdateWithoutPostInput!
  where: PreferredDayAndTimeWhereUniqueInput!
}

input PreferredDayAndTimeUpdateWithoutPostInput {
  dayAndTime: StringFieldUpdateOperationsInput
}

input PreferredDayAndTimeUpsertWithWhereUniqueWithoutPostInput {
  create: PreferredDayAndTimeCreateWithoutPostInput!
  update: PreferredDayAndTimeUpdateWithoutPostInput!
  where: PreferredDayAndTimeWhereUniqueInput!
}

input PreferredDayAndTimeWhereInput {
  AND: [PreferredDayAndTimeWhereInput!]
  NOT: [PreferredDayAndTimeWhereInput!]
  OR: [PreferredDayAndTimeWhereInput!]
  dayAndTime: StringFilter
  id: IntFilter
  post: PostRelationFilter
  postId: IntFilter
}

input PreferredDayAndTimeWhereUniqueInput {
  id: Int
}

type Query {
  aggregateGym(cursor: GymWhereUniqueInput, orderBy: [GymOrderByWithRelationInput!], skip: Int, take: Int, where: GymWhereInput): AggregateGym!
  aggregatePost(cursor: PostWhereUniqueInput, orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): AggregatePost!
  aggregatePreferredDayAndTime(cursor: PreferredDayAndTimeWhereUniqueInput, orderBy: [PreferredDayAndTimeOrderByWithRelationInput!], skip: Int, take: Int, where: PreferredDayAndTimeWhereInput): AggregatePreferredDayAndTime!
  findFirstGym(cursor: GymWhereUniqueInput, distinct: [GymScalarFieldEnum!], orderBy: [GymOrderByWithRelationInput!], skip: Int, take: Int, where: GymWhereInput): Gym
  findFirstGymOrThrow(cursor: GymWhereUniqueInput, distinct: [GymScalarFieldEnum!], orderBy: [GymOrderByWithRelationInput!], skip: Int, take: Int, where: GymWhereInput): Gym
  findFirstPost(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): Post
  findFirstPostOrThrow(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): Post
  findFirstPreferredDayAndTime(cursor: PreferredDayAndTimeWhereUniqueInput, distinct: [PreferredDayAndTimeScalarFieldEnum!], orderBy: [PreferredDayAndTimeOrderByWithRelationInput!], skip: Int, take: Int, where: PreferredDayAndTimeWhereInput): PreferredDayAndTime
  findFirstPreferredDayAndTimeOrThrow(cursor: PreferredDayAndTimeWhereUniqueInput, distinct: [PreferredDayAndTimeScalarFieldEnum!], orderBy: [PreferredDayAndTimeOrderByWithRelationInput!], skip: Int, take: Int, where: PreferredDayAndTimeWhereInput): PreferredDayAndTime
  getGym(where: GymWhereUniqueInput!): Gym
  getPost(where: PostWhereUniqueInput!): Post
  getPreferredDayAndTime(where: PreferredDayAndTimeWhereUniqueInput!): PreferredDayAndTime
  groupByGym(by: [GymScalarFieldEnum!]!, having: GymScalarWhereWithAggregatesInput, orderBy: [GymOrderByWithAggregationInput!], skip: Int, take: Int, where: GymWhereInput): [GymGroupBy!]!
  groupByPost(by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, orderBy: [PostOrderByWithAggregationInput!], skip: Int, take: Int, where: PostWhereInput): [PostGroupBy!]!
  groupByPreferredDayAndTime(by: [PreferredDayAndTimeScalarFieldEnum!]!, having: PreferredDayAndTimeScalarWhereWithAggregatesInput, orderBy: [PreferredDayAndTimeOrderByWithAggregationInput!], skip: Int, take: Int, where: PreferredDayAndTimeWhereInput): [PreferredDayAndTimeGroupBy!]!
  gym(where: GymWhereUniqueInput!): Gym
  gyms(cursor: GymWhereUniqueInput, distinct: [GymScalarFieldEnum!], orderBy: [GymOrderByWithRelationInput!], skip: Int, take: Int, where: GymWhereInput): [Gym!]!
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  preferredDayAndTime(where: PreferredDayAndTimeWhereUniqueInput!): PreferredDayAndTime
  preferredDayAndTimes(cursor: PreferredDayAndTimeWhereUniqueInput, distinct: [PreferredDayAndTimeScalarFieldEnum!], orderBy: [PreferredDayAndTimeOrderByWithRelationInput!], skip: Int, take: Int, where: PreferredDayAndTimeWhereInput): [PreferredDayAndTime!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}